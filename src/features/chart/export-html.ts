import type { ChartSettings, TreeNode } from "../../domain";

export interface StandaloneChartDocumentInput {
  datasetName: string;
  tree: TreeNode;
  depthLimit: number;
  chartSettings: ChartSettings | null;
}

export function createStandaloneChartDocument(input: StandaloneChartDocumentInput): string {
  const payload = serializeJsonForScriptTag({
    name: input.datasetName,
    tree: input.tree,
    depthLimit: input.depthLimit,
    chartSettings: input.chartSettings,
  });

  return `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${escapeHtml(input.datasetName)}</title>
    <style>${STANDALONE_STYLE}</style>
  </head>
  <body>
    <div class="app-shell">
      <div class="app-frame chart-screen-frame">
        <header class="panel row space-between">
          <div>
            <h1 id="chart-title">Chart</h1>
            <div id="chart-subtitle" class="muted"></div>
            <div class="generated-by muted">
              Generated by
              <a href="https://github.com/owebeeone/jowna" target="_blank" rel="noreferrer noopener">
                Jowna
              </a>
            </div>
          </div>
        </header>

        <div class="panel row chart-toolbar space-between">
          <div class="row">
            <button id="btn-back" class="ghost">Back</button>
            <button id="btn-forward" class="ghost">Forward</button>
            <button id="btn-up" class="ghost">Up</button>
            <button id="btn-reset" class="ghost">Reset</button>
            <button id="btn-toggle-details" class="ghost">Hide Details</button>
            <label class="row chart-collapse-wrap">
              <input id="collapse-input" type="checkbox" />
              <span>Collapse</span>
            </label>
            <button id="btn-download-svg" class="ghost">Download SVG</button>
          </div>
          <div class="row depth-wrap">
            <span class="muted">Depth</span>
            <input id="depth-input" type="number" min="0" max="12" />
          </div>
        </div>

        <div id="breadcrumbs" class="panel chart-breadcrumbs"></div>

        <div id="chart-layout" class="chart-layout">
          <section class="chart-surface chart-surface-krona">
            <svg id="chart-svg" class="chart-canvas chart-canvas-krona" viewBox="0 0 620 620" role="img">
              <g id="chart-root" transform="translate(310 310)"></g>
            </svg>
            <div class="chart-hint muted">Click a segment to zoom. Hover to inspect. Click center to move up.</div>
          </section>

          <aside id="chart-details" class="panel stack chart-details">
            <h3 id="details-heading">Details</h3>
            <div id="details-content" class="stack"></div>
            <div class="stack">
              <h3>Top Segments</h3>
              <div id="top-segments" class="stack"></div>
            </div>
          </aside>
        </div>
      </div>
    </div>

    <script id="jowna-export-data" type="application/json">${payload}</script>
    <script>${STANDALONE_SCRIPT}</script>
  </body>
</html>
`;
}

export function toStandaloneChartFileName(datasetName: string): string {
  const normalized = datasetName
    .trim()
    .replace(/[^a-zA-Z0-9._-]+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");

  const base = normalized.length > 0 ? normalized : "dataset-chart";
  return `${base}.html`;
}

function escapeHtml(value: string): string {
  return value
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

function serializeJsonForScriptTag(value: unknown): string {
  return JSON.stringify(value)
    .replaceAll("<", "\\u003c")
    .replaceAll(">", "\\u003e")
    .replaceAll("&", "\\u0026")
    .replaceAll("\u2028", "\\u2028")
    .replaceAll("\u2029", "\\u2029");
}

const STANDALONE_STYLE = `
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: sans-serif;
}

.app-shell {
  min-height: 100vh;
  background: radial-gradient(circle at 20% 0%, #e2f4ea, #f6f8f7 45%, #eef3f1 100%);
  color: #12251c;
}

.app-frame {
  max-width: 1280px;
  margin: 0 auto;
  padding: 24px;
  display: grid;
  gap: 16px;
}

.app-frame.chart-screen-frame {
  max-width: none;
  width: 100%;
}

.panel {
  background: #ffffff;
  border: 1px solid #d6dfda;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 10px rgba(15, 32, 24, 0.06);
}

.panel h1,
.panel h2,
.panel h3 {
  margin: 0;
}

.row {
  display: flex;
  gap: 8px;
  align-items: center;
}

.stack {
  display: grid;
  gap: 8px;
}

.space-between {
  justify-content: space-between;
}

.muted {
  color: #52675d;
  font-size: 0.9rem;
}

.generated-by {
  margin-top: 4px;
}

.generated-by a {
  color: inherit;
  text-decoration: underline;
}

button,
input {
  font: inherit;
}

input {
  width: 100%;
  border: 1px solid #c5d1ca;
  border-radius: 8px;
  padding: 8px;
  background: #fbfdfc;
}

.chart-collapse-wrap {
  border: 1px solid #c5d1ca;
  border-radius: 8px;
  padding: 6px 10px;
  background: #ffffff;
}

.chart-collapse-wrap input[type="checkbox"] {
  width: auto;
  margin: 0;
}

button {
  border: 1px solid #1f6f4d;
  border-radius: 8px;
  padding: 8px 12px;
  background: #1f6f4d;
  color: #ffffff;
  cursor: pointer;
}

button.ghost {
  background: #ffffff;
  color: #1f6f4d;
}

button:disabled {
  opacity: 0.6;
  cursor: default;
}

.depth-wrap {
  min-width: 220px;
}

.chart-layout {
  display: grid;
  grid-template-columns: minmax(0, 1fr) 320px;
  gap: 16px;
  align-items: start;
}

.chart-layout.is-details-hidden {
  grid-template-columns: minmax(0, 1fr);
}

.chart-surface {
  background: #ffffff;
  border: 1px solid #d6dfda;
  border-radius: 12px;
  padding: 12px;
  min-height: 0;
}

.chart-surface-krona {
  background:
    radial-gradient(circle at 50% 40%, #f9fdfb 0%, #f4faf7 38%, #ebf3ee 100%),
    #ffffff;
}

.chart-canvas {
  width: 100%;
  height: 600px;
  display: block;
}

.chart-canvas-krona {
  height: clamp(560px, calc(100vh - 270px), 1400px);
  overflow: visible;
}

.chart-layout.is-details-hidden .chart-canvas-krona {
  height: clamp(620px, calc(100vh - 230px), 1600px);
}

.chart-breadcrumbs {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.crumb {
  border: 1px solid #bfd2c8;
  background: #f4faf7;
  color: #194533;
  border-radius: 999px;
  padding: 5px 10px;
  line-height: 1.2;
}

.crumb.is-current {
  border-color: #175d3f;
  background: #1f6f4d;
  color: #ffffff;
}

.chart-wedge {
  cursor: pointer;
  transition:
    opacity 160ms ease,
    stroke-width 180ms ease,
    filter 160ms ease;
}

.chart-wedge:hover {
  filter: brightness(1.07) saturate(1.06);
}

.chart-wedge.is-active {
  filter: brightness(1.08) saturate(1.12);
}

.chart-wedge.is-focus {
  filter: saturate(1.14);
}

.chart-wedge-label {
  fill: #0e2b1f;
  font-size: 11px;
  font-weight: 600;
  pointer-events: none;
  text-rendering: geometricPrecision;
}

.chart-label-tooltip {
  pointer-events: none;
}

.chart-label-tooltip-box {
  fill: #ffffff;
}

.chart-label-tooltip-text {
  fill: #102a1f;
  font-weight: 600;
}

.chart-center-disc {
  fill: #f4faf7;
  stroke: #c4d8cc;
  stroke-width: 1.4;
  cursor: pointer;
}

.chart-center-title {
  font-size: 13px;
  font-weight: 700;
  fill: #102a1f;
}

.chart-center-metric {
  font-size: 15px;
  font-weight: 700;
  fill: #174936;
}

.chart-center-sub {
  font-size: 11px;
  fill: #4f675d;
}

.chart-hint {
  text-align: center;
}

.chart-details {
  max-height: 700px;
  overflow: auto;
}

.chart-stats {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
}

.chart-stat {
  border: 1px solid #d4e1db;
  border-radius: 10px;
  background: #f7fbf9;
  padding: 8px;
  display: grid;
  gap: 2px;
}

.key-row {
  border: 1px solid #d0ddd6;
  background: #ffffff;
  color: #1c3d30;
  border-radius: 8px;
  padding: 8px 10px;
  width: 100%;
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  gap: 8px;
}

.key-row:hover {
  border-color: #96b9a8;
  background: #f4faf7;
}

.key-row.is-active {
  border-color: #1f6f4d;
  background: #e8f4ed;
}

.key-label {
  text-align: left;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.key-value {
  font-variant-numeric: tabular-nums;
  color: #335a4a;
}

.legend-dot {
  display: inline-block;
  width: 10px;
  height: 10px;
  border-radius: 99px;
  margin-right: 6px;
}

@media (max-width: 980px) {
  .chart-layout {
    grid-template-columns: 1fr;
  }

  .chart-surface {
    min-height: 480px;
  }

  .chart-canvas {
    height: 460px;
  }

  .chart-canvas-krona {
    height: 500px;
  }

  .chart-layout.is-details-hidden .chart-canvas-krona {
    height: 540px;
  }

  .chart-stats {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}
`;

const STANDALONE_SCRIPT = `
(function () {
  var OUTER_RADIUS = 270;
  var MAX_KEY_SEGMENTS = 10;
  var MIN_LABEL_FONT_SIZE = 4;
  var KRONA_SATURATION = 0.5;
  var KRONA_LIGHTNESS_BASE = 0.6;
  var KRONA_LIGHTNESS_MAX = 0.8;
  var KRONA_UNCLASSIFIED_COLOR = "rgb(220,220,220)";
  var SVG_NS = "http://www.w3.org/2000/svg";

  var payload = readPayload();
  if (!payload || !payload.tree || typeof payload.tree.name !== "string") {
    showFatal("Missing chart dataset payload.");
    return;
  }

  var dataset = payload;
  var chartSettings = resolveChartSettings(payload.chartSettings);
  var rootPath = [dataset.tree.name];
  var state = {
    focusPath: rootPath.slice(),
    selectedPath: rootPath.slice(),
    hoverPath: null,
    detailsPanelCollapsed: false,
    history: [rootPath.slice()],
    historyIndex: 0,
    depthLimit: normalizeDepthLimit(payload.depthLimit),
  };

  var elements = {
    title: byId("chart-title"),
    subtitle: byId("chart-subtitle"),
    backButton: byId("btn-back"),
    forwardButton: byId("btn-forward"),
    upButton: byId("btn-up"),
    resetButton: byId("btn-reset"),
    toggleDetailsButton: byId("btn-toggle-details"),
    collapseInput: byId("collapse-input"),
    downloadSvgButton: byId("btn-download-svg"),
    depthInput: byId("depth-input"),
    breadcrumbs: byId("breadcrumbs"),
    chartLayout: byId("chart-layout"),
    chartDetails: byId("chart-details"),
    chartSurface: byClass("chart-surface"),
    chartSvg: byId("chart-svg"),
    chartRoot: byId("chart-root"),
    detailsHeading: byId("details-heading"),
    detailsContent: byId("details-content"),
    topSegments: byId("top-segments"),
  };

  var datasetName = typeof dataset.name === "string" && dataset.name.length > 0 ? dataset.name : "Dataset";
  document.title = datasetName;
  elements.title.textContent = datasetName;
  elements.subtitle.textContent = datasetName;
  elements.depthInput.value = String(state.depthLimit);
  elements.collapseInput.checked = chartSettings.collapseRedundant !== false;
  applyChartSettings();
  applyDetailsPanelVisibility();

  bindControls();
  render();

  function bindControls() {
    elements.backButton.addEventListener("click", function () {
      if (state.historyIndex <= 0) {
        return;
      }
      state.historyIndex -= 1;
      var path = state.history[state.historyIndex];
      state.focusPath = path.slice();
      state.selectedPath = path.slice();
      state.hoverPath = null;
      render();
    });

    elements.forwardButton.addEventListener("click", function () {
      if (state.historyIndex >= state.history.length - 1) {
        return;
      }
      state.historyIndex += 1;
      var path = state.history[state.historyIndex];
      state.focusPath = path.slice();
      state.selectedPath = path.slice();
      state.hoverPath = null;
      render();
    });

    elements.upButton.addEventListener("click", function () {
      var focusPath = state.focusPath && state.focusPath.length > 0 ? state.focusPath : rootPath;
      if (focusPath.length <= 1) {
        return;
      }
      setFocusPath(focusPath.slice(0, -1), true);
    });

    elements.resetButton.addEventListener("click", function () {
      state.focusPath = rootPath.slice();
      state.selectedPath = rootPath.slice();
      state.hoverPath = null;
      state.history = [rootPath.slice()];
      state.historyIndex = 0;
      render();
    });

    elements.toggleDetailsButton.addEventListener("click", function () {
      state.detailsPanelCollapsed = !state.detailsPanelCollapsed;
      applyDetailsPanelVisibility();
    });

    elements.downloadSvgButton.addEventListener("click", function () {
      downloadCurrentSvg();
    });

    elements.depthInput.addEventListener("input", function () {
      state.depthLimit = normalizeDepthLimit(elements.depthInput.value);
      render();
    });

    elements.collapseInput.addEventListener("change", function () {
      chartSettings.collapseRedundant = !!elements.collapseInput.checked;
      render();
    });
  }

  function render() {
    var layout = computeLayout(dataset.tree, state.focusPath, state.depthLimit);
    var colorLayout = computeLayout(dataset.tree, null, 0);
    var kronaColors = buildKronaColorMap(colorLayout);

    var resolvedFocusPath = state.focusPath && state.focusPath.length > 0 ? state.focusPath : rootPath;
    var activePath = state.hoverPath || state.selectedPath || resolvedFocusPath;
    var activeNode = findNodeByPath(dataset.tree, activePath);
    var activeLayoutNode = findLayoutNodeByPath(layout.nodes, activePath);

    var totalMagnitude = layout.totalMagnitude;
    var activeMagnitude = activeLayoutNode ? activeLayoutNode.magnitude : activeNode ? activeNode.magnitude : 0;
    var activeShare = totalMagnitude > 0 ? (activeMagnitude / totalMagnitude) * 100 : 0;
    var layoutDataMaxDepth = computeLayoutDataMaxDepth(layout);
    var renderDepth = resolveRenderDepth(layoutDataMaxDepth, state.depthLimit);
    var maxDepth = renderDepth;
    var radiusScale = createRadiusScale(renderDepth, OUTER_RADIUS);
    var wedgeRenderPlan = createWedgeRenderPlan(
      layout,
      renderDepth,
      Math.max(MIN_LABEL_FONT_SIZE, chartSettings.fontSizePx),
      radiusScale
    );
    var parentFocusPath = resolvedFocusPath.length > 1 ? resolvedFocusPath.slice(0, -1) : null;

    renderToolbar(parentFocusPath);
    renderBreadcrumbs(resolvedFocusPath);
    renderSvg(
      layout,
      kronaColors,
      activePath,
      resolvedFocusPath,
      activeNode,
      activeMagnitude,
      activeShare,
      radiusScale,
      maxDepth,
      parentFocusPath,
      wedgeRenderPlan
    );
    renderDetails(activeNode, activePath, activeMagnitude, activeShare);
    renderTopSegments(layout, totalMagnitude, activePath, kronaColors);
  }

  function applyChartSettings() {
    document.body.style.fontFamily = resolveFontFamily(chartSettings.fontFamily);

    if (elements.chartSurface) {
      elements.chartSurface.style.background = chartSettings.background;
      elements.chartSurface.style.borderWidth = String(chartSettings.borderWidth) + "px";
      elements.chartSurface.style.borderColor = chartSettings.borderColor;
    }

    if (elements.chartSvg) {
      if (typeof chartSettings.width === "number" && chartSettings.width > 0) {
        elements.chartSvg.style.width = String(chartSettings.width) + "px";
      } else {
        elements.chartSvg.style.width = "";
      }
      if (typeof chartSettings.height === "number" && chartSettings.height > 0) {
        elements.chartSvg.style.height = String(chartSettings.height) + "px";
      } else {
        elements.chartSvg.style.height = "";
      }
      elements.chartSvg.style.overflow = "visible";
    }
  }

  function applyDetailsPanelVisibility() {
    if (!elements.chartLayout || !elements.chartDetails) {
      return;
    }

    if (state.detailsPanelCollapsed) {
      elements.chartLayout.classList.add("is-details-hidden");
      elements.chartDetails.setAttribute("hidden", "hidden");
      elements.toggleDetailsButton.textContent = "Show Details";
    } else {
      elements.chartLayout.classList.remove("is-details-hidden");
      elements.chartDetails.removeAttribute("hidden");
      elements.toggleDetailsButton.textContent = "Hide Details";
    }
  }

  function renderToolbar(parentFocusPath) {
    elements.backButton.disabled = state.historyIndex <= 0;
    elements.forwardButton.disabled = state.historyIndex >= state.history.length - 1;
    elements.upButton.disabled = !parentFocusPath;
  }

  function renderBreadcrumbs(focusPath) {
    clearElement(elements.breadcrumbs);
    var focusLabel = document.createElement("span");
    focusLabel.className = "muted";
    focusLabel.textContent = "Focus";
    elements.breadcrumbs.appendChild(focusLabel);

    for (var index = 0; index < focusPath.length; index += 1) {
      var crumbPath = focusPath.slice(0, index + 1);
      var button = document.createElement("button");
      button.className = "crumb" + (index === focusPath.length - 1 ? " is-current" : "");
      button.textContent = focusPath[index];
      button.addEventListener("click", createFocusHandler(crumbPath));
      elements.breadcrumbs.appendChild(button);
    }
  }

  function renderSvg(
    layout,
    kronaColors,
    activePath,
    resolvedFocusPath,
    activeNode,
    activeMagnitude,
    activeShare,
    radiusScale,
    maxDepth,
    parentFocusPath,
    wedgeRenderPlan
  ) {
    clearElement(elements.chartRoot);
    ensureHiddenPattern();

    var renderNodes = wedgeRenderPlan.visibleNodes;
    for (var index = 0; index < renderNodes.length; index += 1) {
      var renderNode = renderNodes[index];
      var node = renderNode.node;
      var interactionPath = renderNode.interactionPath;
      if (node.depth <= 0) {
        continue;
      }

      var innerRadius = radiusScale(node.depth - 1);
      var outerRadius = radiusScale(renderNode.outerDepth);
      var pathData = arcPath(innerRadius, outerRadius, node.startAngle, node.endAngle);
      if (!pathData) {
        continue;
      }

      var isInteractive = interactionPath.length > 0 && !isUnclassifiedNodeName(node.name);
      var isActive = isInteractive && activePath ? pathEquals(interactionPath, activePath) : false;
      var isFocused = isInteractive && resolvedFocusPath ? pathEquals(interactionPath, resolvedFocusPath) : false;
      var fill = isUnclassifiedNodeName(node.name)
        ? KRONA_UNCLASSIFIED_COLOR
        : resolveNodeFillColor(
            kronaColors,
            [renderNode.colorPath || node.path, interactionPath, node.path],
            KRONA_UNCLASSIFIED_COLOR
          );

      var pathElement = createSvgElement("path");
      pathElement.setAttribute("class", "chart-wedge" + (isActive ? " is-active" : "") + (isFocused ? " is-focus" : ""));
      pathElement.setAttribute("d", pathData);
      pathElement.setAttribute("fill", fill);
      pathElement.setAttribute("stroke", isActive ? "#062d1e" : chartSettings.wedgeStrokeColor);
      pathElement.setAttribute(
        "stroke-width",
        isActive ? "2.2" : String(Math.max(0.4, chartSettings.wedgeStrokeWidth))
      );
      pathElement.setAttribute(
        "opacity",
        isInteractive && state.hoverPath ? (isActive ? "1" : "0.42") : (isFocused ? "1" : "0.92")
      );

      if (isInteractive) {
        pathElement.setAttribute("role", "button");
        pathElement.setAttribute("tabindex", "0");
        pathElement.addEventListener("mouseenter", createHoverHandler(interactionPath));
        pathElement.addEventListener("mouseleave", clearHoverHandler);
        pathElement.addEventListener("click", createFocusHandler(interactionPath));
        pathElement.addEventListener("pointerdown", createFocusHandler(interactionPath));
      }

      var title = createSvgElement("title");
      title.textContent = renderNode.isGroupedHidden
        ? String(renderNode.hiddenCount) + " more"
        : node.path.join(" / ") + ": " + formatNumber(node.magnitude);
      pathElement.appendChild(title);
      elements.chartRoot.appendChild(pathElement);

      if (renderNode.isGroupedHidden) {
        var patternPath = createSvgElement("path");
        patternPath.setAttribute("d", pathData);
        patternPath.setAttribute("fill", "url(#chart-hidden-pattern)");
        patternPath.setAttribute("stroke", "none");
        patternPath.setAttribute("opacity", "0.65");
        patternPath.setAttribute("pointer-events", "none");
        elements.chartRoot.appendChild(patternPath);
      }
    }

    for (var labelIndex = 0; labelIndex < renderNodes.length; labelIndex += 1) {
      var labelRenderNode = renderNodes[labelIndex];
      var labelNode = labelRenderNode.node;
      var labelInteractionPath = labelRenderNode.interactionPath;
      if (labelNode.depth <= 0) {
        continue;
      }
      var labelInnerRadius = radiusScale(labelNode.depth - 1);
      var labelOuterRadius = radiusScale(labelRenderNode.outerDepth);
      var label = createWedgeLabel(
        labelNode,
        labelInnerRadius,
        labelOuterRadius,
        maxDepth,
        labelRenderNode.outerDepth,
        Math.max(MIN_LABEL_FONT_SIZE, chartSettings.fontSizePx)
      );
      if (!label) {
        continue;
      }

      var showTooltip = !!state.hoverPath && pathEquals(labelInteractionPath, state.hoverPath) && label.isTruncated;
      if (showTooltip) {
        var tooltip = createHoverLabelTooltip(
          label,
          Math.max(MIN_LABEL_FONT_SIZE, chartSettings.fontSizePx)
        );
        var tooltipGroup = createSvgElement("g");
        tooltipGroup.setAttribute("class", "chart-label-tooltip");
        tooltipGroup.setAttribute("pointer-events", "none");

        var tooltipBox = createSvgElement("rect");
        tooltipBox.setAttribute("class", "chart-label-tooltip-box");
        tooltipBox.setAttribute("x", String(tooltip.x));
        tooltipBox.setAttribute("y", String(tooltip.y));
        tooltipBox.setAttribute("width", String(tooltip.width));
        tooltipBox.setAttribute("height", String(tooltip.height));
        tooltipBox.setAttribute("rx", "7");
        tooltipBox.setAttribute("ry", "7");
        tooltipBox.setAttribute("fill", "#ffffff");
        tooltipBox.setAttribute("stroke", chartSettings.wedgeStrokeColor);
        tooltipBox.setAttribute("stroke-width", String(Math.max(0.4, chartSettings.wedgeStrokeWidth) + 0.5));
        tooltipGroup.appendChild(tooltipBox);

        var tooltipText = createSvgElement("text");
        tooltipText.setAttribute("class", "chart-label-tooltip-text");
        tooltipText.setAttribute("x", String(tooltip.textX));
        tooltipText.setAttribute("y", String(tooltip.textY));
        tooltipText.setAttribute("text-anchor", "middle");
        tooltipText.setAttribute("dominant-baseline", "middle");
        tooltipText.setAttribute("font-family", chartSettings.fontFamily);
        tooltipText.setAttribute(
          "font-size",
          String(Math.max(MIN_LABEL_FONT_SIZE, chartSettings.fontSizePx))
        );
        tooltipText.textContent = label.fullText;
        tooltipGroup.appendChild(tooltipText);

        elements.chartRoot.appendChild(tooltipGroup);
      }

      var text = createSvgElement("text");
      text.setAttribute("class", "chart-wedge-label");
      text.setAttribute("x", String(label.x));
      text.setAttribute("y", String(label.y));
      text.setAttribute("text-anchor", label.anchor);
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("transform", "rotate(" + label.rotate + " " + label.x + " " + label.y + ")");
      text.setAttribute("font-family", chartSettings.fontFamily);
      text.setAttribute(
        "font-size",
        String(Math.max(MIN_LABEL_FONT_SIZE, chartSettings.fontSizePx))
      );
      text.textContent = label.text;
      elements.chartRoot.appendChild(text);
    }

    var centerDisc = createSvgElement("circle");
    centerDisc.setAttribute("r", String(radiusScale(0) + 42));
    centerDisc.setAttribute("class", "chart-center-disc");
    centerDisc.addEventListener("click", function () {
      if (parentFocusPath) {
        setFocusPath(parentFocusPath, true);
      } else {
        state.focusPath = rootPath.slice();
        state.selectedPath = rootPath.slice();
        state.hoverPath = null;
        render();
      }
    });
    elements.chartRoot.appendChild(centerDisc);

    var centerTitle = createSvgElement("text");
    centerTitle.setAttribute("x", "0");
    centerTitle.setAttribute("y", "-18");
    centerTitle.setAttribute("text-anchor", "middle");
    centerTitle.setAttribute("class", "chart-center-title");
    centerTitle.textContent = activeNode ? activeNode.name : (resolvedFocusPath[resolvedFocusPath.length - 1] || "Root");
    elements.chartRoot.appendChild(centerTitle);

    var centerMetric = createSvgElement("text");
    centerMetric.setAttribute("x", "0");
    centerMetric.setAttribute("y", "2");
    centerMetric.setAttribute("text-anchor", "middle");
    centerMetric.setAttribute("class", "chart-center-metric");
    centerMetric.textContent = formatNumber(activeMagnitude);
    elements.chartRoot.appendChild(centerMetric);

    var centerSub = createSvgElement("text");
    centerSub.setAttribute("x", "0");
    centerSub.setAttribute("y", "22");
    centerSub.setAttribute("text-anchor", "middle");
    centerSub.setAttribute("class", "chart-center-sub");
    centerSub.textContent = activeShare.toFixed(1) + "% of view";
    elements.chartRoot.appendChild(centerSub);
  }

  function ensureHiddenPattern() {
    if (!elements.chartSvg) {
      return;
    }

    var existing = elements.chartSvg.querySelector("#chart-hidden-pattern");
    if (existing) {
      return;
    }

    var defs = elements.chartSvg.querySelector("defs");
    if (!defs) {
      defs = createSvgElement("defs");
      elements.chartSvg.insertBefore(defs, elements.chartSvg.firstChild);
    }

    var pattern = createSvgElement("pattern");
    pattern.setAttribute("id", "chart-hidden-pattern");
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    pattern.setAttribute("x", "0");
    pattern.setAttribute("y", "0");
    pattern.setAttribute("width", "7");
    pattern.setAttribute("height", "7");

    var lineA = createSvgElement("line");
    lineA.setAttribute("x1", "0");
    lineA.setAttribute("y1", "0");
    lineA.setAttribute("x2", "3.5");
    lineA.setAttribute("y2", "3.5");
    lineA.setAttribute("stroke", "rgba(16,36,27,0.35)");
    lineA.setAttribute("stroke-width", "0.8");
    pattern.appendChild(lineA);

    var lineB = createSvgElement("line");
    lineB.setAttribute("x1", "3.5");
    lineB.setAttribute("y1", "7");
    lineB.setAttribute("x2", "7");
    lineB.setAttribute("y2", "3.5");
    lineB.setAttribute("stroke", "rgba(16,36,27,0.35)");
    lineB.setAttribute("stroke-width", "0.8");
    pattern.appendChild(lineB);

    defs.appendChild(pattern);
  }

  function createWedgeRenderPlan(layout, maxDepth, labelFontSize, radiusScale) {
    if (!layout || !layout.nodes || layout.nodes.length === 0) {
      return { visibleNodes: [] };
    }

    var visibleNodes = layout.nodes.filter(function (node) {
      return node.depth > 0;
    });
    if (visibleNodes.length === 0 || maxDepth <= 0) {
      return {
        visibleNodes: visibleNodes.map(function (node) {
          return {
            node: node,
            isGroupedHidden: false,
            hiddenCount: 0,
            key: pathKey(node.path),
            colorPath: node.path,
            interactionPath: node.path,
            outerDepth: node.depth,
          };
        }),
      };
    }

    var minVisibleWidth = Math.max(MIN_LABEL_FONT_SIZE, labelFontSize) * 2.3;
    var childrenByParent = new Map();
    var visiblePathKeys = new Set(
      visibleNodes.map(function (node) {
        return pathKey(node.path);
      })
    );
    for (var index = 0; index < visibleNodes.length; index += 1) {
      var current = visibleNodes[index];
      var parent = pathKey(current.path.slice(0, -1));
      var children = childrenByParent.get(parent);
      if (children) {
        children.push(current);
      } else {
        childrenByParent.set(parent, [current]);
      }
    }

    childrenByParent.forEach(function (children) {
      children.sort(function (left, right) {
        if (left.startAngle !== right.startAngle) {
          return left.startAngle - right.startAngle;
        }
        return left.endAngle - right.endAngle;
      });
    });

    var groupedNodes = [];
    childrenByParent.forEach(function (children, parentKey) {
      var cursor = 0;
      var hiddenGroupIndex = 0;
      while (cursor < children.length) {
        var child = children[cursor];
        if (!shouldGroupHiddenChild(child, radiusScale, minVisibleWidth)) {
          groupedNodes.push({
            node: child,
            isGroupedHidden: false,
            hiddenCount: 0,
            key: pathKey(child.path),
            colorPath: child.path,
            interactionPath: child.path,
            outerDepth: child.depth,
          });
          cursor += 1;
          continue;
        }

        var runEnd = cursor;
        while (
          runEnd + 1 < children.length &&
          shouldGroupHiddenChild(children[runEnd + 1], radiusScale, minVisibleWidth)
        ) {
          runEnd += 1;
        }

        var run = children.slice(cursor, runEnd + 1);
        var first = run[0];
        var last = run[run.length - 1];
        var parentPath = first.path.slice(0, -1);
        var interactionPath = parentPath.length > 0 ? parentPath : first.path;
        var groupedColorPath = resolveGroupedColorPath(parentPath, first.path, visiblePathKeys);
        var hiddenCount = run.length;
        var groupedMagnitude = run.reduce(function (sum, item) {
          return sum + item.magnitude;
        }, 0);

        groupedNodes.push({
          node: {
            path: first.path.slice(0, -1).concat([String(hiddenCount) + " more"]),
            name: String(hiddenCount) + " more",
            depth: first.depth,
            magnitude: groupedMagnitude,
            startAngle: first.startAngle,
            endAngle: last.endAngle,
          },
          isGroupedHidden: true,
          hiddenCount: hiddenCount,
          key: parentKey + "/[" + hiddenCount + "-more-" + hiddenGroupIndex + "]",
          colorPath: groupedColorPath,
          interactionPath: interactionPath,
          outerDepth: first.depth,
        });

        hiddenGroupIndex += 1;
        cursor = runEnd + 1;
      }
    });

    groupedNodes.sort(function (left, right) {
      if (left.node.depth !== right.node.depth) {
        return left.node.depth - right.node.depth;
      }
      if (left.node.startAngle !== right.node.startAngle) {
        return left.node.startAngle - right.node.startAngle;
      }
      if (left.node.endAngle !== right.node.endAngle) {
        return left.node.endAngle - right.node.endAngle;
      }
      return left.key.localeCompare(right.key);
    });

    var parentKeys = new Set(groupedNodes.map(function (entry) {
      return pathKey(entry.node.path.slice(0, -1));
    }));
    return {
      visibleNodes: groupedNodes.map(function (entry) {
        return {
          node: entry.node,
          isGroupedHidden: entry.isGroupedHidden,
          hiddenCount: entry.hiddenCount,
          key: entry.key,
          colorPath: entry.colorPath,
          interactionPath: entry.interactionPath,
          outerDepth: parentKeys.has(pathKey(entry.node.path)) ? entry.node.depth : maxDepth,
        };
      }),
    };
  }

  function shouldGroupHiddenChild(child, radiusScale, minVisibleWidth) {
    var innerRadius = radiusScale(child.depth - 1);
    var outerRadius = radiusScale(child.depth);
    var angleSpan = Math.max(0, child.endAngle - child.startAngle);
    var widthEstimate = angleSpan * (innerRadius + outerRadius);
    return widthEstimate < minVisibleWidth;
  }

  function resolveGroupedColorPath(parentPath, fallbackPath, visiblePathKeys) {
    for (var length = parentPath.length; length >= 2; length -= 1) {
      var candidate = parentPath.slice(0, length);
      if (visiblePathKeys.has(pathKey(candidate))) {
        return candidate;
      }
    }
    return fallbackPath;
  }

  function renderDetails(activeNode, activePath, activeMagnitude, activeShare) {
    elements.detailsHeading.textContent = state.hoverPath ? "Hover Details" : "Details";
    clearElement(elements.detailsContent);

    if (!activeNode) {
      appendText(elements.detailsContent, "div", "muted", "Hover or click a wedge to inspect node details.");
      return;
    }

    var titleBlock = document.createElement("div");
    var strong = document.createElement("strong");
    strong.textContent = activeNode.name;
    titleBlock.appendChild(strong);
    elements.detailsContent.appendChild(titleBlock);

    appendText(elements.detailsContent, "div", "muted", "path: " + (activePath ? activePath.join(" / ") : ""));

    var stats = document.createElement("div");
    stats.className = "chart-stats";
    stats.appendChild(createStat("Magnitude", formatNumber(activeMagnitude)));
    stats.appendChild(createStat("Share", activeShare.toFixed(1) + "%"));
    stats.appendChild(createStat("Children", String(activeNode.children ? activeNode.children.length : 0)));
    elements.detailsContent.appendChild(stats);

    if (activeNode.description) {
      appendText(elements.detailsContent, "div", "", activeNode.description);
    }

    if (activeNode.url) {
      var urlBlock = document.createElement("div");
      var link = document.createElement("a");
      link.href = activeNode.url;
      link.target = "_blank";
      link.rel = "noreferrer";
      link.textContent = activeNode.url;
      urlBlock.appendChild(link);
      elements.detailsContent.appendChild(urlBlock);
    }

    var attributes = activeNode.attributes || {};
    var attributeKeys = Object.keys(attributes);
    if (attributeKeys.length > 0) {
      var attributeContainer = document.createElement("div");
      attributeContainer.className = "stack";
      for (var index = 0; index < attributeKeys.length; index += 1) {
        var key = attributeKeys[index];
        var row = document.createElement("div");
        row.className = "muted";
        var keyStrong = document.createElement("strong");
        keyStrong.textContent = key + ":";
        row.appendChild(keyStrong);
        row.appendChild(document.createTextNode(" " + String(attributes[key])));
        attributeContainer.appendChild(row);
      }
      elements.detailsContent.appendChild(attributeContainer);
    }
  }

  function renderTopSegments(layout, totalMagnitude, activePath, kronaColors) {
    clearElement(elements.topSegments);

    var topLevel = layout.nodes
      .filter(function (node) {
        return node.depth === 1 && !isUnclassifiedNodeName(node.name);
      })
      .sort(function (left, right) {
        if (right.magnitude !== left.magnitude) {
          return right.magnitude - left.magnitude;
        }
        return left.name.localeCompare(right.name);
      });

    if (topLevel.length === 0) {
      appendText(elements.topSegments, "div", "muted", "No segments in the current view.");
      return;
    }

    var visible = topLevel.slice(0, MAX_KEY_SEGMENTS);
    for (var index = 0; index < visible.length; index += 1) {
      var node = visible[index];
      var share = totalMagnitude > 0 ? (node.magnitude / totalMagnitude) * 100 : 0;
      var isActive = activePath ? pathEquals(node.path, activePath) : false;

      var keyButton = document.createElement("button");
      keyButton.className = "key-row" + (isActive ? " is-active" : "");
      keyButton.addEventListener("mouseenter", createHoverHandler(node.path));
      keyButton.addEventListener("mouseleave", clearHoverHandler);
      keyButton.addEventListener("click", createFocusHandler(node.path));
      keyButton.addEventListener("pointerdown", createFocusHandler(node.path));

      var dot = document.createElement("span");
      dot.className = "legend-dot";
      dot.style.background = resolveNodeFillColor(kronaColors, [node.path], KRONA_UNCLASSIFIED_COLOR);
      keyButton.appendChild(dot);

      var label = document.createElement("span");
      label.className = "key-label";
      label.textContent = node.name;
      keyButton.appendChild(label);

      var value = document.createElement("span");
      value.className = "key-value";
      value.textContent = share.toFixed(1) + "%";
      keyButton.appendChild(value);

      elements.topSegments.appendChild(keyButton);
    }

    var hidden = topLevel.length - visible.length;
    if (hidden > 0) {
      appendText(elements.topSegments, "div", "muted", "+ " + hidden + " more in this level");
    }
  }

  function createStat(label, value) {
    var stat = document.createElement("div");
    stat.className = "chart-stat";
    appendText(stat, "span", "muted", label);
    appendText(stat, "strong", "", value);
    return stat;
  }

  function createHoverHandler(path) {
    return function () {
      state.hoverPath = path.slice();
      render();
    };
  }

  function clearHoverHandler() {
    if (!state.hoverPath) {
      return;
    }
    state.hoverPath = null;
    render();
  }

  function createFocusHandler(path) {
    return function () {
      setFocusPath(path, true);
    };
  }

  function setFocusPath(path, trackHistory) {
    var normalized = normalizePath(path);
    if (normalized.length === 0) {
      return;
    }
    if (!findNodeByPath(dataset.tree, normalized)) {
      return;
    }
    var focusUnchanged = state.focusPath && pathEquals(state.focusPath, normalized);

    state.focusPath = normalized;
    state.selectedPath = normalized;
    state.hoverPath = null;

    if (trackHistory && !focusUnchanged) {
      var historyPrefix = state.history.slice(0, state.historyIndex + 1);
      historyPrefix.push(normalized.slice());
      state.history = historyPrefix;
      state.historyIndex = state.history.length - 1;
    }

    render();
  }

  function normalizePath(path) {
    if (!Array.isArray(path)) {
      return rootPath.slice();
    }
    var normalized = path
      .map(function (segment) {
        return String(segment).trim();
      })
      .filter(function (segment) {
        return segment.length > 0;
      });

    if (normalized.length === 0 || normalized[0] !== rootPath[0]) {
      return rootPath.slice();
    }
    return normalized;
  }

  function computeLayout(root, focusedPath, depthLimitInput) {
    var normalizedFocusPath = normalizeFocusedPath(root, focusedPath);
    var focusedRoot = resolveFocusedNode(root, normalizedFocusPath) || root;
    var pathPrefix = normalizedFocusPath ? normalizedFocusPath.slice(0, -1) : [];
    var totalMagnitude = computeEffectiveMagnitude(focusedRoot);
    var collapseRedundant = chartSettings.collapseRedundant !== false;
    var rootHasMultipleChildren = Array.isArray(dataset.tree.children) && dataset.tree.children.length > 1;
    var depthLimit = depthLimitInput <= 0 ? null : depthLimitInput;
    var nodes = flattenForLayout({
      node: focusedRoot,
      pathPrefix: pathPrefix,
      depth: 0,
      startAngle: 0,
      angleSpan: totalMagnitude > 0 ? Math.PI * 2 : 0,
      depthLimit: depthLimit,
      collapseRedundant: collapseRedundant,
      rootHasMultipleChildren: rootHasMultipleChildren,
    });

    return {
      nodes: nodes,
      totalMagnitude: totalMagnitude,
    };
  }

  function flattenForLayout(args) {
    var currentPath = args.pathPrefix.concat([args.node.name]);
    var nodeMagnitude = computeEffectiveMagnitude(args.node);
    var angleSpan = Math.max(0, args.angleSpan);

    var currentNode = {
      path: currentPath,
      name: args.node.name,
      depth: args.depth,
      magnitude: nodeMagnitude,
      startAngle: args.startAngle,
      endAngle: args.startAngle + angleSpan,
    };

    var nodes = [currentNode];
    if (
      !Array.isArray(args.node.children) ||
      args.node.children.length === 0 ||
      (typeof args.depthLimit === "number" && args.depth >= args.depthLimit)
    ) {
      return nodes;
    }

    var resolvedChildren = args.node.children
      .map(function (child) {
        var collapsed = resolveCollapsedChild(
          child,
          args.collapseRedundant,
          args.rootHasMultipleChildren
        );
        return {
          child: collapsed.node,
          pathSegments: collapsed.pathSegments,
          magnitude: computeEffectiveMagnitude(collapsed.node),
        };
      })
      .filter(function (entry) {
        return entry.magnitude > 0;
      });

    var childEntries = resolvedChildren.map(function (entry) {
      return {
        child: entry.child,
        pathSegments: entry.pathSegments,
        magnitude: entry.magnitude,
        isUnclassified: false,
      };
    });

    var childrenTotalMagnitude = childEntries.reduce(function (sum, entry) {
      return sum + entry.magnitude;
    }, 0);
    var unclassifiedMagnitude = Math.max(0, nodeMagnitude - childrenTotalMagnitude);
    if (unclassifiedMagnitude > 0.000000001) {
      childEntries.push({
        child: null,
        pathSegments: [getUnclassifiedName(args.node.name)],
        magnitude: unclassifiedMagnitude,
        isUnclassified: true,
      });
    }

    var childStartAngle = args.startAngle;
    for (var index = 0; index < childEntries.length; index += 1) {
      var entry = childEntries[index];
      var childAngleSpan = nodeMagnitude === 0 ? 0 : (entry.magnitude / nodeMagnitude) * angleSpan;
      if (entry.isUnclassified || !entry.child) {
        nodes.push({
          path: currentPath.concat(entry.pathSegments),
          name: entry.pathSegments[entry.pathSegments.length - 1] || "Unclassified",
          depth: args.depth + 1,
          magnitude: entry.magnitude,
          startAngle: childStartAngle,
          endAngle: childStartAngle + childAngleSpan,
        });
      } else {
        var childNodes = flattenForLayout({
          node: entry.child,
          pathPrefix: currentPath.concat(entry.pathSegments.slice(0, -1)),
          depth: args.depth + 1,
          startAngle: childStartAngle,
          angleSpan: childAngleSpan,
          depthLimit: args.depthLimit,
          collapseRedundant: args.collapseRedundant,
          rootHasMultipleChildren: args.rootHasMultipleChildren,
        });
        nodes = nodes.concat(childNodes);
      }
      childStartAngle += childAngleSpan;
    }

    return nodes;
  }

  function computeEffectiveMagnitude(node) {
    var nodeMagnitude = normalizeMagnitude(node.magnitude);
    if (!Array.isArray(node.children) || node.children.length === 0) {
      return nodeMagnitude;
    }
    var childrenMagnitude = node.children.reduce(function (sum, child) {
      return sum + computeEffectiveMagnitude(child);
    }, 0);
    return Math.max(nodeMagnitude, childrenMagnitude);
  }

  function normalizeMagnitude(value) {
    var numberValue = Number(value);
    if (!Number.isFinite(numberValue) || numberValue <= 0) {
      return 0;
    }
    return numberValue;
  }

  function getUnclassifiedName(parentName) {
    return "[other " + String(parentName) + "]";
  }

  function resolveCollapsedChild(node, collapseRedundant, rootHasMultipleChildren) {
    var pathSegments = [node.name];
    var candidate = node;

    if (!collapseRedundant) {
      return {
        node: candidate,
        pathSegments: pathSegments,
      };
    }

    while (isCollapsibleNode(candidate, rootHasMultipleChildren)) {
      var child = Array.isArray(candidate.children) ? candidate.children[0] : null;
      if (!child) {
        break;
      }
      candidate = child;
      pathSegments.push(child.name);
    }

    return {
      node: candidate,
      pathSegments: pathSegments,
    };
  }

  function isCollapsibleNode(node, rootHasMultipleChildren) {
    if (!Array.isArray(node.children) || node.children.length !== 1) {
      return false;
    }
    var child = node.children[0];
    var nodeMagnitude = computeEffectiveMagnitude(node);
    var childMagnitude = computeEffectiveMagnitude(child);
    if (Math.abs(nodeMagnitude - childMagnitude) > 0.000000001) {
      return false;
    }
    return rootHasMultipleChildren || (Array.isArray(child.children) && child.children.length > 0);
  }

  function resolveFocusedNode(root, focusedPath) {
    if (!focusedPath || focusedPath.length === 0) {
      return root;
    }
    var head = focusedPath[0];
    if (head !== root.name) {
      return null;
    }
    var cursor = root;
    for (var index = 1; index < focusedPath.length; index += 1) {
      var segment = focusedPath[index];
      var next = Array.isArray(cursor.children)
        ? cursor.children.find(function (child) {
            return child.name === segment;
          })
        : null;
      if (!next) {
        return null;
      }
      cursor = next;
    }
    return cursor;
  }

  function normalizeFocusedPath(root, focusedPath) {
    if (!Array.isArray(focusedPath) || focusedPath.length === 0) {
      return null;
    }
    var normalized = focusedPath
      .map(function (segment) {
        return String(segment).trim();
      })
      .filter(function (segment) {
        return segment.length > 0;
      });

    if (normalized.length === 0 || normalized[0] !== root.name) {
      return null;
    }
    return normalized;
  }

  function findLayoutNodeByPath(nodes, path) {
    if (!path) {
      return null;
    }
    for (var index = 0; index < nodes.length; index += 1) {
      if (pathEquals(nodes[index].path, path)) {
        return nodes[index];
      }
    }
    return null;
  }

  function findNodeByPath(root, path) {
    if (!path || path.length === 0) {
      return root;
    }

    if (path[0] !== root.name) {
      return null;
    }

    var cursor = root;
    for (var index = 1; index < path.length; index += 1) {
      var segment = path[index];
      var next = Array.isArray(cursor.children)
        ? cursor.children.find(function (child) {
            return child.name === segment;
          })
        : null;
      if (!next) {
        return null;
      }
      cursor = next;
    }

    return cursor;
  }

  function arcPath(innerRadius, outerRadius, startAngle, endAngle) {
    if (endAngle <= startAngle) {
      return "";
    }

    var largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
    var outerStart = polarPoint(outerRadius, startAngle);
    var outerEnd = polarPoint(outerRadius, endAngle);

    if (innerRadius <= 0) {
      return (
        "M " +
        outerStart.x +
        " " +
        outerStart.y +
        " A " +
        outerRadius +
        " " +
        outerRadius +
        " 0 " +
        largeArc +
        " 1 " +
        outerEnd.x +
        " " +
        outerEnd.y +
        " L 0 0 Z"
      );
    }

    var innerEnd = polarPoint(innerRadius, endAngle);
    var innerStart = polarPoint(innerRadius, startAngle);

    return (
      "M " +
      outerStart.x +
      " " +
      outerStart.y +
      " A " +
      outerRadius +
      " " +
      outerRadius +
      " 0 " +
      largeArc +
      " 1 " +
      outerEnd.x +
      " " +
      outerEnd.y +
      " L " +
      innerEnd.x +
      " " +
      innerEnd.y +
      " A " +
      innerRadius +
      " " +
      innerRadius +
      " 0 " +
      largeArc +
      " 0 " +
      innerStart.x +
      " " +
      innerStart.y +
      " Z"
    );
  }

  function polarPoint(radius, angle) {
    return {
      x: Math.cos(angle + Math.PI / 2) * radius,
      y: Math.sin(angle + Math.PI / 2) * radius,
    };
  }

  function createRadiusScale(maxDepth, outerRadius) {
    return function (depth) {
      if (depth <= 0 || maxDepth <= 0) {
        return 0;
      }
      var normalized = depth / maxDepth;
      return Math.pow(normalized, 0.86) * outerRadius;
    };
  }

  function computeLayoutDataMaxDepth(layout) {
    if (!layout || !layout.nodes || layout.nodes.length === 0) {
      return 0;
    }

    var maxDepth = 0;
    for (var index = 0; index < layout.nodes.length; index += 1) {
      var node = layout.nodes[index];
      if (node.depth <= 0 || isUnclassifiedNodeName(node.name)) {
        continue;
      }
      if (node.depth > maxDepth) {
        maxDepth = node.depth;
      }
    }

    if (maxDepth > 0) {
      return maxDepth;
    }
    return maxNodeDepth(layout.nodes);
  }

  function resolveRenderDepth(treeMaxDepth, depthLimit) {
    if (treeMaxDepth <= 0) {
      return 0;
    }
    if (depthLimit <= 0) {
      return treeMaxDepth;
    }
    return Math.min(depthLimit, treeMaxDepth);
  }

  function createWedgeLabel(node, innerRadius, outerRadius, maxDepth, outerDepth, fontSizePx) {
    var isOuterRing = maxDepth <= 1 || outerDepth >= maxDepth;
    var angleSpan = node.endAngle - node.startAngle;
    var ringThickness = outerRadius - innerRadius;
    var radius = innerRadius + ringThickness * (isOuterRing ? 0.6 : 0.56);
    var tangentialSpan = radius * angleSpan;

    var minAngleSpan = isOuterRing ? 0.007 : 0.04;
    var minRingThickness = isOuterRing ? 6 : 10;
    var minTangentialSpan = isOuterRing ? 2 : 10;

    if (
      angleSpan < minAngleSpan ||
      ringThickness < minRingThickness ||
      tangentialSpan < minTangentialSpan
    ) {
      return null;
    }

    var midAngle = (node.startAngle + node.endAngle) / 2;
    var point = polarPoint(radius, midAngle);

    var approximateCharWidth = Math.max(4, fontSizePx * 0.58);
    var availableTextLength = isOuterRing
      ? Math.max(0, ringThickness - fontSizePx * 0.45)
      : Math.max(0, tangentialSpan - fontSizePx * 0.35);
    var maxChars = Math.max(isOuterRing ? 4 : 6, Math.floor(availableTextLength / approximateCharWidth));
    var isTruncated = node.name.length > maxChars;
    var text = ellipsize(node.name, maxChars);
    var baseRotation = isOuterRing ? (midAngle * 180) / Math.PI - 90 : (midAngle * 180) / Math.PI;
    var normalizedRotation = normalizeDegrees(baseRotation);
    var flip = normalizedRotation > 90 || normalizedRotation < -90;
    var rotate = flip ? normalizedRotation + 180 : normalizedRotation;

    return {
      text: text,
      fullText: node.name,
      isTruncated: isTruncated,
      x: point.x,
      y: point.y,
      rotate: rotate,
      anchor: isOuterRing ? (flip ? "end" : "start") : "middle",
    };
  }

  function createHoverLabelTooltip(label, fontSizePx) {
    var horizontalPadding = 9;
    var verticalPadding = 5;
    var approxTextWidth = Math.max(20, label.fullText.length * fontSizePx * 0.58);
    var width = approxTextWidth + horizontalPadding * 2;
    var height = fontSizePx + verticalPadding * 2 + 2;
    var centerX = label.x;
    var centerY = label.y - fontSizePx * 1.2;

    return {
      x: centerX - width / 2,
      y: centerY - height / 2,
      width: width,
      height: height,
      textX: centerX,
      textY: centerY,
    };
  }

  function ellipsize(value, maxLength) {
    if (value.length <= maxLength) {
      return value;
    }
    return value.slice(0, Math.max(0, maxLength - 3)) + "...";
  }

  function buildKronaColorMap(layout) {
    var colors = new Map();
    if (!layout || !layout.nodes || layout.nodes.length === 0) {
      return colors;
    }

    var root = layout.nodes.find(function (node) {
      return node.depth === 0;
    }) || layout.nodes[0];
    var existingPathKeys = new Set(
      layout.nodes.map(function (node) {
        return pathKey(node.path);
      })
    );
    var childrenByParent = new Map();
    for (var index = 0; index < layout.nodes.length; index += 1) {
      var node = layout.nodes[index];
      if (isUnclassifiedNodeName(node.name)) {
        colors.set(pathKey(node.path), KRONA_UNCLASSIFIED_COLOR);
        continue;
      }
      if (node.depth === 0) {
        continue;
      }
      var parent = pathKey(
        resolveNearestExistingAncestorPath(node.path.slice(0, -1), existingPathKeys)
      );
      var children = childrenByParent.get(parent);
      if (children) {
        children.push(node);
      } else {
        childrenByParent.set(parent, [node]);
      }
    }

    childrenByParent.forEach(function (children) {
      children.sort(function (left, right) {
        if (left.startAngle !== right.startAngle) {
          return left.startAngle - right.startAngle;
        }
        return left.endAngle - right.endAngle;
      });
    });

    var maxDepth = computeLayoutDataMaxDepth(layout);
    var depthNormalizer = maxDepth > 8 ? 8 : Math.max(maxDepth, 1);
    var lightnessFactor = (KRONA_LIGHTNESS_MAX - KRONA_LIGHTNESS_BASE) / depthNormalizer;

    function assignColor(node, hueMin, hueMax) {
      var boundedHueMax = hueMax;
      if (boundedHueMax - hueMin > 1 / 12) {
        boundedHueMax = hueMin + 1 / 12;
      }

      if (node.depth > 0) {
        if (node.magnitude <= 0 || isUnclassifiedNodeName(node.name)) {
          colors.set(pathKey(node.path), KRONA_UNCLASSIFIED_COLOR);
        } else {
          var lightness = Math.min(
            KRONA_LIGHTNESS_MAX,
            KRONA_LIGHTNESS_BASE + (node.depth - 1) * lightnessFactor
          );
          var rgb = hslToRgb(hueMin, KRONA_SATURATION, lightness);
          colors.set(pathKey(node.path), rgbText(rgb.r, rgb.g, rgb.b));
        }
      }

      var children = childrenByParent.get(pathKey(node.path)) || [];
      if (children.length === 0) {
        return;
      }

      for (var childIndex = 0; childIndex < children.length; childIndex += 1) {
        var child = children[childIndex];
        var childHueMin;
        var childHueMax;

        if (node.depth === 0) {
          if (children.length > 6) {
            childHueMin = (1 - Math.pow(1 - childIndex / children.length, 1.4)) * 0.95;
            childHueMax = (1 - Math.pow(1 - (childIndex + 0.55) / children.length, 1.4)) * 0.95;
          } else {
            childHueMin = childIndex / children.length;
            childHueMax = (childIndex + 0.55) / children.length;
          }
        } else {
          childHueMin = lerp(child.startAngle, node.startAngle, node.endAngle, hueMin, boundedHueMax);
          childHueMax = lerp(
            child.startAngle + (child.endAngle - child.startAngle) * 0.99,
            node.startAngle,
            node.endAngle,
            hueMin,
            boundedHueMax
          );
        }

        assignColor(child, childHueMin, childHueMax);
      }
    }

    assignColor(root, 0, 1);
    return colors;
  }

  function resolveNodeFillColor(colors, candidatePaths, fallbackColor) {
    for (var index = 0; index < candidatePaths.length; index += 1) {
      var candidate = candidatePaths[index];
      if (!Array.isArray(candidate) || candidate.length === 0) {
        continue;
      }
      for (var length = candidate.length; length >= 1; length -= 1) {
        var color = colors.get(pathKey(candidate.slice(0, length)));
        if (typeof color === "string" && color.length > 0) {
          return color;
        }
      }
    }
    return fallbackColor;
  }

  function resolveNearestExistingAncestorPath(path, existingPathKeys) {
    for (var length = path.length; length >= 0; length -= 1) {
      var candidate = path.slice(0, length);
      if (existingPathKeys.has(pathKey(candidate))) {
        return candidate;
      }
    }
    return [];
  }

  function lerp(value, rangeStart, rangeEnd, outputStart, outputEnd) {
    if (rangeEnd === rangeStart) {
      return outputStart;
    }
    return outputStart + ((value - rangeStart) / (rangeEnd - rangeStart)) * (outputEnd - outputStart);
  }

  function rgbText(red, green, blue) {
    return "rgb(" + red + "," + green + "," + blue + ")";
  }

  function hslToRgb(hue, saturation, lightness) {
    if (saturation === 0) {
      var value = Math.floor(lightness * 255);
      return { r: value, g: value, b: value };
    }

    var m2 = lightness <= 0.5
      ? lightness * (saturation + 1)
      : lightness + saturation - lightness * saturation;
    var m1 = lightness * 2 - m2;

    return {
      r: Math.floor(hueToRgb(m1, m2, hue + 1 / 3)),
      g: Math.floor(hueToRgb(m1, m2, hue)),
      b: Math.floor(hueToRgb(m1, m2, hue - 1 / 3)),
    };
  }

  function hueToRgb(m1, m2, hue) {
    var normalizedHue = hue;
    while (normalizedHue < 0) {
      normalizedHue += 1;
    }
    while (normalizedHue > 1) {
      normalizedHue -= 1;
    }

    var value;
    if (6 * normalizedHue < 1) {
      value = m1 + (m2 - m1) * normalizedHue * 6;
    } else if (2 * normalizedHue < 1) {
      value = m2;
    } else if (3 * normalizedHue < 2) {
      value = m1 + (m2 - m1) * (2 / 3 - normalizedHue) * 6;
    } else {
      value = m1;
    }

    return value * 255;
  }

  function maxNodeDepth(nodes) {
    var max = 0;
    for (var index = 0; index < nodes.length; index += 1) {
      if (nodes[index].depth > max) {
        max = nodes[index].depth;
      }
    }
    return max;
  }

  function pathEquals(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (var index = 0; index < left.length; index += 1) {
      if (left[index] !== right[index]) {
        return false;
      }
    }
    return true;
  }

  function pathKey(path) {
    return path.join("/");
  }

  function isUnclassifiedNodeName(name) {
    return String(name).trim().toLowerCase().indexOf("[other ") === 0;
  }

  function normalizeDegrees(angle) {
    var normalized = angle;
    while (normalized <= -180) {
      normalized += 360;
    }
    while (normalized > 180) {
      normalized -= 360;
    }
    return normalized;
  }

  function resolveChartSettings(raw) {
    var defaults = {
      background: "#f6f8f7",
      borderWidth: 0,
      borderColor: "#b7c2bc",
      wedgeStrokeWidth: 1,
      wedgeStrokeColor: "#ffffff",
      collapseRedundant: true,
      fontFamily: "sans-serif",
      fontSizePx: 12,
      width: "fit",
      height: "fit",
      colorScheme: ["#0f6b48", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"],
    };

    if (!raw || typeof raw !== "object") {
      return defaults;
    }

    var width = raw.width;
    var height = raw.height;
    var normalizedWidth =
      typeof width === "number" && Number.isFinite(width) && width > 0 ? width : "fit";
    var normalizedHeight =
      typeof height === "number" && Number.isFinite(height) && height > 0 ? height : "fit";

    return {
      background: typeof raw.background === "string" ? raw.background : defaults.background,
      borderWidth:
        typeof raw.borderWidth === "number" && Number.isFinite(raw.borderWidth)
          ? Math.max(0, raw.borderWidth)
          : defaults.borderWidth,
      borderColor: typeof raw.borderColor === "string" ? raw.borderColor : defaults.borderColor,
      wedgeStrokeWidth:
        typeof raw.wedgeStrokeWidth === "number" && Number.isFinite(raw.wedgeStrokeWidth)
          ? Math.max(0.4, raw.wedgeStrokeWidth)
          : defaults.wedgeStrokeWidth,
      wedgeStrokeColor:
        typeof raw.wedgeStrokeColor === "string"
          ? raw.wedgeStrokeColor
          : defaults.wedgeStrokeColor,
      collapseRedundant:
        typeof raw.collapseRedundant === "boolean"
          ? raw.collapseRedundant
          : defaults.collapseRedundant,
      fontFamily: typeof raw.fontFamily === "string" ? raw.fontFamily : defaults.fontFamily,
      fontSizePx:
        typeof raw.fontSizePx === "number" && Number.isFinite(raw.fontSizePx)
          ? Math.max(MIN_LABEL_FONT_SIZE, raw.fontSizePx)
          : defaults.fontSizePx,
      width: normalizedWidth,
      height: normalizedHeight,
      colorScheme: Array.isArray(raw.colorScheme) ? raw.colorScheme : defaults.colorScheme,
    };
  }

  function resolveFontFamily(fontFamily) {
    if (typeof fontFamily !== "string" || fontFamily.trim().length === 0) {
      return "sans-serif";
    }
    if (fontFamily.includes(",")) {
      return fontFamily;
    }
    return (
      fontFamily +
      ", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif"
    );
  }

  function normalizeDepthLimit(value) {
    var parsed = Number(value);
    if (!Number.isFinite(parsed)) {
      return 0;
    }
    if (parsed < 0) {
      return 0;
    }
    if (parsed > 12) {
      return 12;
    }
    return Math.floor(parsed);
  }

  function byId(id) {
    var element = document.getElementById(id);
    if (!element) {
      throw new Error("Missing element #" + id);
    }
    return element;
  }

  function byClass(className) {
    var element = document.querySelector("." + className);
    if (!element) {
      throw new Error("Missing element ." + className);
    }
    return element;
  }

  function clearElement(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }

  function createSvgElement(tagName) {
    return document.createElementNS(SVG_NS, tagName);
  }

  function appendText(container, tagName, className, value) {
    var element = document.createElement(tagName);
    if (className) {
      element.className = className;
    }
    element.textContent = value;
    container.appendChild(element);
  }

  function formatNumber(value) {
    return Number(value || 0).toLocaleString();
  }

  function downloadCurrentSvg() {
    var fileName = toSvgFileName(datasetName);
    var svgMarkup = serializeSvgForDownload(elements.chartSvg);
    downloadTextFile(fileName, svgMarkup, "image/svg+xml;charset=utf-8");
  }

  function serializeSvgForDownload(svgElement) {
    var clone = svgElement.cloneNode(true);
    clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    clone.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

    var viewBox = clone.getAttribute("viewBox");
    if (typeof viewBox === "string" && viewBox.length > 0) {
      var parts = viewBox
        .trim()
        .split(/\\s+/)
        .map(function (part) {
          return Number.parseFloat(part);
        });
      if (
        parts.length === 4 &&
        Number.isFinite(parts[0]) &&
        Number.isFinite(parts[1]) &&
        Number.isFinite(parts[2]) &&
        Number.isFinite(parts[3])
      ) {
        clone.setAttribute("width", String(parts[2]));
        clone.setAttribute("height", String(parts[3]));
      }
    }

    var style = createSvgElement("style");
    style.textContent =
      ".chart-wedge-label{fill:#0e2b1f;font-weight:600}" +
      ".chart-label-tooltip{pointer-events:none}" +
      ".chart-label-tooltip-box{fill:#ffffff}" +
      ".chart-label-tooltip-text{fill:#102a1f;font-weight:600}" +
      ".chart-center-disc{fill:#f4faf7;stroke:#c4d8cc;stroke-width:1.4}" +
      ".chart-center-title{font-size:13px;font-weight:700;fill:#102a1f}" +
      ".chart-center-metric{font-size:15px;font-weight:700;fill:#174936}" +
      ".chart-center-sub{font-size:11px;fill:#4f675d}";
    clone.insertBefore(style, clone.firstChild);

    return '<?xml version="1.0" encoding="UTF-8"?>\\n' + clone.outerHTML;
  }

  function toSvgFileName(name) {
    var normalized = String(name || "")
      .trim()
      .replace(/[^a-zA-Z0-9._-]+/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
    var base = normalized.length > 0 ? normalized : "dataset-chart";
    return base + ".svg";
  }

  function downloadTextFile(fileName, content, mimeType) {
    var blob = new Blob([content], { type: mimeType });
    var url = URL.createObjectURL(blob);
    var anchor = document.createElement("a");
    anchor.href = url;
    anchor.download = fileName;
    anchor.rel = "noopener";
    anchor.click();
    URL.revokeObjectURL(url);
  }

  function readPayload() {
    var script = document.getElementById("jowna-export-data");
    if (!script || !script.textContent) {
      return null;
    }
    try {
      return JSON.parse(script.textContent);
    } catch (_error) {
      return null;
    }
  }

  function showFatal(message) {
    document.body.innerHTML =
      '<div style="padding:24px;font-family:sans-serif"><h1>Jowna Export</h1><p>' +
      message +
      "</p></div>";
  }
})();
`;
